<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="copyright" content="(C) Copyright 2020"><meta name="DC.rights.owner" content="(C) Copyright 2020"><meta name="DC.type" content="topic"><meta name="DC.format" content="HTML5"><meta name="DC.identifier" content="sending-tokens-by-identifier"><link rel="stylesheet" type="text/css" href="../css/commonltr.css"><link rel="stylesheet" type="text/css" href="../css/custom.css"><title>Sending tokens by identifier</title>
<link href="https://fonts.googleapis.com/css?family=Roboto+Slab|Lato">
<script type="text/javascript" src="https://alphawallet.com/wp-content/themes/alphawallet/discourse/widget.js"></script>
</head><body><header role="banner"><nav class="navbar navbar-expand-lg navbar-dark bg-dark mb-4">
  <div class="container">
    <a class="navbar-brand" href="/">üÜÉokenScript</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
	      <li class="nav-item"><a class="nav-link" href="/TokenScript.html">Documents</a></li>
	      <li class="nav-item"><a class="nav-link" href="/guides/Intro.html">Guides</a></li>
	      <li class="nav-item"><a class="nav-link" href="/specs/Intro.html">Specs</a></li>
	      <li class="nav-item external"><a class="nav-link" href="">TokenScript community forum</a></li>
	      <li class="nav-item external"><a class="nav-link" href="/TokenScript.html">AlphaWallet (uses TokenScript)</a></li>
	      <li class="nav-item external"><a class="nav-link" href="/guides/Intro.html">Github TokenScript</a></li>
	      <li class="nav-item external"><a class="nav-link" href="/specs/Intro.html">Github TokenScript Examples</a></li>
      </ul>
    </div>
  </div>
</nav></header><div class="container" id="content"><div class="row"><nav role="toc" class="col-lg-3"><ul></ul></nav><main role="main" class="col-lg-9"><article role="article" aria-labelledby="ariaid-title1"><article class="nested0" aria-labelledby="ariaid-title1" id="sending-tokens-by-identifier"><h1 class="title topictitle1" id="ariaid-title1">Sending tokens by identifier</h1><div class="body"><section class="section" id="sending-tokens-by-identifier__original-problem"><h2 class="title sectiontitle">Original Problem</h2><p class="p">A user, Alice, wishes to send a token to Bob who might not have a crypto (Ethereum) address. Alice, however, knows an identifier of Bob that can be attested. e.g. Bob's email address or Bob's mobile phone number.</p><p class="p">This approach is made by Alice sending a virtual and anonymous attestation, attesting to Bob's right to redeem that token from Alice through a smart contract.</p></section><section class="section" id="sending-tokens-by-identifier__cheque"><h2 class="title sectiontitle">Cheque</h2><p class="p">We call this kind of attestation <em class="ph i">cheque</em> as it is actionable with a smart contract, comparable to a traditional cheque being redeemable with a bank.</p><p class="p">Such a <em class="ph i">cheque</em> would identify Bob by an identifier and is only actionable if Bob possesses an <em class="ph i">identifier attestation</em> that binds his crypto (Ethereum) address with that identifier.</p></section><section class="section" id="sending-tokens-by-identifier__identifier-attestation"><h2 class="title sectiontitle">Identifier Attestation</h2><p class="p">The identifier - email address or mobile number‚Ä† - can't be learned from an observer with access to the Ethereum blockchain. However, it will be possible for Alice to see that Bob receives cheques from other parties in the future.</p><p class="p">We wish to ensure that only Bob (the attested owner of the identifier <em class="ph i">and</em> the person holding a copy of the cheque) can cash the cheque. Neither a malicious attestor (or someone controlling Bob's identifier) nor a man-in-the-middle who might extract the cheque, will be able to cash the cheque alone.</p><p class="p">Furthermore, we want to allow Bob to be able to reuse his attestation once it is made. So that after redeeming a cheque from Alice, he can also receive a cheque from Carol and redeem it using his attestation without the need for Alice or Carol to communicate.</p><p class="p">The protocol is secure under any composition of senders (Alices) and receivers (Bobs) based on a one-more discrete logarithm-like assumption.</p></section></div></article><article class="topic nested0" aria-labelledby="ariaid-title2" id="protocol"><h1 class="title topictitle1" id="ariaid-title2">Protocol</h1><div class="body"><ul class="ul"><li class="li"><p class="p">We assume that both Alice and Bob know Bob's identifier ùëñ.</p></li><li class="li"><p class="p">We use ùëî<sup class="ph sup">ùë•</sup> to denote the generator element, ùëî, taken ùë• times as apposed to <em class="ph i">G¬∑x</em> in some other works (when using elliptic curve notation).</p></li></ul><section class="section" id="protocol__identifier-attestation-1"><h2 class="title sectiontitle">Identifier Attestation</h2><p class="p">This only needs to be done once for Bob. It can be done either before or after receiving the first cheque.</p><ol class="ol"><li class="li"><p class="p">Bob generates an Ethereum key (if he hasn't already).</p></li><li class="li"><p class="p">Bob generates a privacy key <em class="ph i">p</em>.</p></li><li class="li"><p class="p">Bob creates then computes a hiding of his identifier; <em class="ph i">s=H(i)<sup class="ph sup">p</sup></em>.</p></li><li class="li"><p class="p">He then constructs a zero-knowledge proof that he knows the exponent <em class="ph i">p</em>: He picks random <em class="ph i">r</em> and computes <em class="ph i">t=H(i)<sup class="ph sup">r</sup></em>, <em class="ph i">c=H(s, H(i), t)</em> and <em class="ph i">d=r+c¬∑p</em>. The proof is a function of <em class="ph i">(s, H(i), t, d)</em>.</p></li><li class="li"><p class="p">Bob signs a CSR (signing request) with his identifier <em class="ph i">i</em> using his Ethereum key. He also signs the proof.</p></li><li class="li"><p class="p">An attestor verifies that Bob owns the identifier, that the signatures are valid and that the proof is valid by computing <em class="ph i">c=H(s, H(i), t)</em> and verifying that <em class="ph i">H(i)<sup class="ph sup">d</sup>=t¬∑s<sup class="ph sup">c</sup></em>. If these checks are ok then issue an attestation that binds his Ethereum address with <em class="ph i">s</em> as the subject.</p></li></ol></section><section class="section" id="protocol__cheque-1"><h2 class="title sectiontitle">Cheque</h2><ol class="ol"><li class="li"><p class="p">Alice wishes to send Bob a certain amount of a token and knows Bob's identifier <em class="ph i">i</em>. She creates a one-time-key <em class="ph i">q</em>, computes <em class="ph i">u=H(i)<sup class="ph sup">q</sup></em>.</p></li><li class="li"><p class="p">Alice writes a cheque for anyone to redeem that amount of the token from her smart contract (valid for a certain amount time period). The cheque requires an <em class="ph i">x</em> such that <em class="ph i">u=s<sup class="ph sup">x</sup></em> for a valid attestation on subject <em class="ph i">s</em>.</p></li><li class="li"><p class="p">Alice sends <em class="ph i">q</em> and the cheque to Bob.</p></li></ol></section><section class="section" id="protocol__redeem-the-cheque-with-the-attestation"><h2 class="title sectiontitle">Redeem the Cheque with the Attestation</h2><p class="p">Bob computes a value <em class="ph i">x=p<sup class="ph sup">-1</sup>q</em> and, in a redeeming transaction, constructs a Fiat-Shamir based Schnorr proof-of-knowledge that it knows <em class="ph i">x</em> s.t. <em class="ph i">u=s<sup class="ph sup">x</sup></em>. That is, Bob proceeds as follows:</p><ol class="ol"><li class="li"><p class="p">Pick random <em class="ph i">r</em> and compute <em class="ph i">t=s<sup class="ph sup">r</sup></em></p></li><li class="li"><p class="p">Next compute <em class="ph i">c=H(s, u, t)</em></p></li><li class="li"><p class="p">Finally compute <em class="ph i">d=r+c¬∑x</em></p></li><li class="li"><p class="p">Bob then signs <em class="ph i">(s, u, t, d)</em> and the attestation (whose subject is <em class="ph i">s</em>) and sends all these values and the signature to the smart contract.</p></li></ol><p class="p">The smart contract computes:</p><ol class="ol"><li class="li"><p class="p">That the amount in the attestation is less than Alice's balance.</p></li><li class="li"><p class="p">The attestation is a valid attestation that binds <em class="ph i">s</em> to Bob (transaction sender) 's Ethereum address.</p></li><li class="li"><p class="p">That the signatures is correct.</p></li><li class="li"><p class="p"><em class="ph i">c=H(s, u, t)</em> and verifies that <em class="ph i">s<sup class="ph sup">d</sup>=t¬∑u<sup class="ph sup">c</sup></em></p></li><li class="li"><p class="p">That the cheque is still valid.</p></li></ol><p class="p">If all predicates are satisfied, emits the pay to Bob.</p></section></div></article><article class="topic nested0" aria-labelledby="ariaid-title3" id="generalisation-of-the-protocol"><h1 class="title topictitle1" id="ariaid-title3">Generalisation of the protocol</h1><div class="body"><p class="shortdesc">The cheque in this case can be a generic attestation.
This protocol has two attestations:</p><ol class="ol"><li class="li"><p class="p">cheque, which is a kind of attestation to trigger an action.</p></li><li class="li"><p class="p">identifier attestation, issued by an identifier attestor, which enables the beneficiary of the cheque to perform an action (redeem).</p></li></ol><p class="p">The first attestation here does not have to be a cheque. Instead, it can be a normal attestation. Such generalisation was used in, for example, ticketing, where the first attestation attests to the rights of entering the venue corresponding to the ticket.</p><p class="p">In such case where both are attestations, the "subject" of the 1st attestation, for example, <code class="ph codeph">numero=1280</code>, indicating the ticket ID 1280, can be used as an identifier attestation for another 3rd party attestation, which attests something to the ticket (although the hiding might not be necessary in such a use case). Here two examples are provided:</p><ul class="ul"><li class="li"><p class="p">A speaker of the conference can invite a ticket holder to a closed-door meeting. Such an invitation is an attestation on the ticket ID. Such an invitation is, again, used as a ticket.</p></li><li class="li"><p class="p">CO‚ÇÇ coin is an issuer of carbon credits for someone who paid to offset their carbon footprint. They can issue an attestation on the ticket ID, attesting to the fact that the ticket's carbon footprint has offset. Such attestation enables access to privileged online service or discounts.</p></li></ul></div></article><article class="topic nested0" aria-labelledby="ariaid-title4" id="implementation-issues"><h1 class="title topictitle1" id="ariaid-title4">Implementation Issues</h1><div class="body"><section class="section" id="implementation-issues__implementations-based-on-elliptic-curves"><h2 class="title sectiontitle">Implementations based on elliptic curves</h2><p class="p">We note that despite having described the protocol using general multiplication group notation, the implementations will be based on elliptic curves. Therefore, <em class="ph i">s</em> will be a point on an elliptic curve computed as <em class="ph i">G¬∑p</em> where <em class="ph i">G</em> is a generator computed deterministically from <em class="ph i">H(i)</em>. Furthermore, this also means that the computation in step 3 for Bob and the smart contract will happen over the integers, modulo the curve order.
We note that it is crucial that the generator <em class="ph i">G</em> is derived from a hash-to-curve paradigm on the identifier <em class="ph i">i</em>, and <strong class="ph b">not</strong> as <em class="ph i">G'^H(i)</em> from a base-generator <em class="ph i">G'</em>. Otherwise it will become trivial to break the binding to <em class="ph i">i</em> which <em class="ph i">s</em> is supposed to aford along with the hiding of <em class="ph i">i</em>.</p><p class="p"><a class="xref" href="https://crypto.stackexchange.com/questions/34863/ec-schnorr-signature-multiple-standard" target="_blank" rel="external noopener">This post</a> mentions some standards for EC-based Fiat-Shamir Schnorr proofs and thus where to look for further details.</p></section><section class="section" id="implementation-issues__in-the-case-of-using-a-javascript-deployed-as-a-service"><h2 class="title sectiontitle">In the case of using a JavaScript deployed as a service</h2><p class="p">Furthermore, we note that there does not seem to be standard Javascript libraries to compute such an elliptic curve Fiat-Shamir Schnorr proof. Thus this could be allowed to be supported by a third party (specifically step 1-3 for Bob). However, if such a library is malicious, it will learn <em class="ph i">x</em> and thus be able to impersonate Bob. This <em class="ph i">must</em> not happen. Thus instead of constructing a proof of knowledge of <em class="ph i">x</em> s.t. <em class="ph i">s'=s<sup class="ph sup">x</sup></em> Bob uses such a library to construct a proof of knowledge of <em class="ph i">x+w</em> s.t. <em class="ph i">s'=<sup class="ph sup">x+w</sup></em> for a random <em class="ph i">w</em>. Based on this Bob will instead send <em class="ph i">(s, s', t, d, w)</em> in step 4 and the server will instead verify <em class="ph i">s<sup class="ph sup">d</sup>=t¬∑s'<sup class="ph sup">c¬∑w</sup></em> in step 3.
Still, even this approach does allow for a front-running displacement attack in case the Javascript library sends the query to its owners who also do mining, and so the miner will learn <em class="ph i">x</em> and thus be able to impersonate Bob once he tried to cash the cheque.</p><p class="p">However, it might still be possible to easily implement this in Javascript, as SubtleCrypto.deriveKey supports the construction of an ECDH key which can be used to construct the value <em class="ph i">r</em> and <em class="ph i">t</em> in step 1 for Bob over an elliptic curve. Since hashing is also readily supported, step 2 can also easily be implemented. Furthermore, Javascript also supports big integer arithmetic through BigInt, which is needed to compute step 3. Thus the only real issue that might not be trivial is to extract the BigInt representation of <em class="ph i">r</em> along with the curve order.</p></section></div></article></article></main></div></div></body></html>